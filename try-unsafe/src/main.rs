use std::slice;

fn main() {
    // Give me a reference to `10`
    // and store it in the `raw_p` pointer
    let raw_p: *const u32 = &10;

    unsafe {
        assert!(*raw_p == 10);
    }

    let some_vector = vec![1, 2, 3, 4];

    let pointer = some_vector.as_ptr();
    let length = some_vector.len();

    unsafe {
        let my_slice: &[u32] = slice::from_raw_parts(pointer, length);
        assert_eq!(some_vector.as_slice(), my_slice);
    }

    // ------ASM examples -----------------
    use std::arch::asm;

    unsafe {
        // This will insert a NOP(no operation)
        // instruction into the assembly
        // generated by the compiler
        asm!("nop");
    }

    let x: u64;
    unsafe {
        // Write the value of `5` into the
        // `u64` variable `x`
        asm!("mov {}, 5", out(reg) x);
    }
    assert_eq!(x, 5);

    let i: u64 = 3;
    let o: u64;
    unsafe {
        // This will add 5 to the input in `i`
        // and write the result to variable `o`.
        // It does this by first copying the value
        // from `i` to the output, and then adding
        // `5` to it.
        asm!(
            "mov {0}, {1}",
            "add {0}, 5",
            out(reg) o,
            in(reg) i,
        );
    }
    assert_eq!(o, 8);

    let mut x: u64 = 3;
    unsafe {
        // `inout` is used to specify an
        // argument that is both input and
        // output
        asm!("add {0}, 5", inout(reg) x);
    }
    assert_eq!(x, 8);

    let mut a: u64 = 4;
    let b: u64 = 4;
    let c: u64 = 4;
    unsafe {
        asm!(
            "add {0}, {1}",
            "add {0}, {2}",
            inout(reg) a,
            in(reg) b,
            in(reg) c,
        );
    }
    assert_eq!(a, 12);
}
